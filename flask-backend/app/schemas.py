# this is auto-generated by swagger-marshmallow-codegen
from __future__ import annotations
from marshmallow import (
    Schema,
    fields,
    INCLUDE,
)
from marshmallow.validate import (
    OneOf,
    Regexp,
)
from app.utils.constants import RAY_N_MODELS
import re


class MLModel(Schema):
    """Data model for compilation of the elements of a machine learning model."""
    acceptableDataSources = fields.List(fields.String(), description='Valid type of input data sources for running the Machine Learning Model')
    algorithm = fields.String(description='The algorithm used by the underlying Machine Learning model (e.g. linear regression, k-means, SVM, MLP,...)')
    alternateName = fields.String(description='An alternative name for this item')
    dataProvider = fields.String(description='A sequence of characters identifying the provider of the harmonised data entity.')
    dateCreated = fields.AwareDateTime(description='Entity creation timestamp. This will usually be allocated by the storage platform.')
    dateModified = fields.AwareDateTime(description='Timestamp of the last modification of the entity. This will usually be allocated by the storage platform.')
    description = fields.String(description='A description of this item')
    dockerImage = fields.String(description='Docker image containing the Machine Learning model')
    id = fields.Field(required=True, description='Unique identifier of the entity')
    inputAttributes = fields.List(fields.String(), description='Comma-separated list of attributes names (that should have a given type by definition).')
    mlFramework = fields.String(description='The Machine Learning framework that has been used to prepare the model (e.g., scikit-learn, H2O, Spark MLib, etc)')
    name = fields.String(description='The name of this item.')
    outputAttributes = fields.List(fields.String(), description='Comma-separated list of attributes names used to publish the results.')
    outputDataTypes = fields.List(fields.String(), description='Type of output data produced by the Machine Learning Model')
    owner = fields.List(fields.Nested(lambda: MLModelOwnerItem(), description='Property. Unique identifier of the entity'), description='A List containing a JSON encoded sequence of characters referencing the unique Ids of the owner(s)')
    refMLProcessing = fields.List(fields.String(), description='')
    seeAlso = fields.Field(description='list of uri pointing to additional resources about the item')
    source = fields.String(description='A sequence of characters giving the original source of the entity data as a URL. Recommended to be the fully qualified domain name of the source provider, or the URL to the source object.')
    type = fields.String(required=True, description='NGSI entity type. It has to be MLModel', validate=[OneOf(choices=['MLModel'], labels=[])])
    typeOfAlgorithm = fields.String(description='Enumeration')
    version = fields.String(description='Version of the model.')
    comment = fields.String(description='Comment about the trained model.')

    class Meta:
        unknown = INCLUDE



class MLModelOwnerItem(Schema):
    """Property. Unique identifier of the entity"""

    class Meta:
        unknown = INCLUDE



class Device(Schema):
    """An apparatus (hardware + software + firmware) intended to accomplish a particular task (sensing the environment, actuating, etc.)."""
    address = fields.Nested(lambda: DeviceAddress(), description='The mailing address')
    alternateName = fields.String(description='An alternative name for this item')
    areaServed = fields.String(description='The geographic area where a service or offered item is provided')
    batteryLevel = fields.Field(description='Device battery level. It must be equal to 1.0 when battery is full. 0.0 when battery is empty. -1 when transiently cannot be determined.')
    category = fields.List(fields.String(validate=[OneOf(choices=['actuator', 'beacon', 'endgun', 'HVAC', 'implement', 'irrSection', 'irrSystem', 'meter', 'multimedia', 'network', 'sensor'], labels=[])]), description="Sensor: A device that detects and responds to events or changes in the physical environment such as light, motion, or temperature changes. https://w3id.org/saref#Sensor. actuator : A device responsible for moving or controlling a mechanism or system. https://w3id.org/saref#Actuator. Meter : A device built to accurately detect and display a quantity in a form readable by a human being. Partially defined by SAREF. HVAC : Heating, Ventilation and Air Conditioning (HVAC) device that provides indoor environmental comfort. https://w3id.org/saref#HVAC. Network : A device used to connect other devices in a network, such as hub, switch or router in a LAN or Sensor network. (https://w3id.org/saref#Network. Multimedia : A device designed to display, store, record or play multimedia content such as audio, images, animation, video. Enum:'actuator, beacon, endgun, HVAC, implement, irrSection, irrSystem, meter, multimedia, network, sensor'")
    configuration = fields.List(fields.Nested(lambda: DeviceConfigurationItem()), description="Device's technical configuration. This attribute is intended to be a array properties and their values which capture parameters which have to do with the configuration of a device (timeouts, reporting periods, etc.) and which are not currently covered by the standard attributes defined by this model.")
    controlledAsset = fields.List(fields.Nested(lambda: DeviceControlledAssetItem()), description='List of the asset(s) (building, object, etc.) controlled by the device.')
    controlledProperty = fields.List(fields.String(validate=[OneOf(choices=['airPollution', 'atmosphericPressure', 'averageVelocity', 'batteryLife', 'batterySupply', 'cdom', 'conductance', 'conductivity', 'depth', 'eatingActivity', 'electricityConsumption', 'energy', 'fillingLevel', 'freeChlorine', 'gasConsumption', 'gateOpening', 'heading', 'humidity', 'light', 'location', 'milking', 'motion', 'movementActivity', 'noiseLevel', 'occupancy', 'orp', 'pH', 'power', 'precipitation', 'pressure', 'refractiveIndex', 'salinity', 'smoke', 'soilMoisture', 'solarRadiation', 'speed', 'tds', 'temperature', 'trafficFlow', 'tss', 'turbidity', 'waterConsumption', 'waterFlow', 'waterLevel', 'waterPollution', 'weatherConditions', 'weight', 'windDirection', 'windSpeed'], labels=[])]), required=True, description="Anything that can be sensed, measured or controlled by. Enum:'airPollution, atmosphericPressure, averageVelocity, batteryLife, batterySupply, cdom, conductance, conductivity, depth, eatingActivity, electricityConsumption, energy, fillingLevel, freeChlorine, gasConsumption, gateOpening, heading, humidity, light, location, milking, motion, movementActivity, noiseLevel, occupancy, orp, pH, power, precipitation, pressure, refractiveIndex, salinity, smoke, soilMoisture, solarRadiation, speed, tds, temperature, trafficFlow, tss, turbidity, waterConsumption, waterFlow, waterLevel, waterPollution, weatherConditions, weight, windDirection, windSpeed'")
    dataProvider = fields.String(description='A sequence of characters identifying the provider of the harmonised data entity.')
    dateCreated = fields.AwareDateTime(description='Entity creation timestamp. This will usually be allocated by the storage platform.')
    dateFirstUsed = fields.AwareDateTime(description='A timestamp which denotes when the device was first used.')
    dateInstalled = fields.AwareDateTime(description='A timestamp which denotes when the device was installed (if it requires installation).')
    dateLastCalibration = fields.AwareDateTime(description='A timestamp which denotes when the last calibration of the device happened.')
    dateLastValueReported = fields.AwareDateTime(description='A timestamp which denotes the last time when the device successfully reported data to the cloud.')
    dateManufactured = fields.AwareDateTime(description='A timestamp which denotes when the device was manufactured.')
    dateModified = fields.AwareDateTime(description='Timestamp of the last modification of the entity. This will usually be allocated by the storage platform.')
    dateObserved = fields.AwareDateTime(description='Date of the observed entity defined by the user.')
    depth = fields.Number(description='Location of this device represented by a depth from a starting point. All units are accepted in [CEFACT](https://www.unece.org/cefact.html) code')
    description = fields.String(description='A description of this item')
    deviceState = fields.String(description='State of this device from an operational point of view. Its value can be vendor dependent.')
    direction = fields.String(description="Enum:'Inlet, Outlet, Entry, Exit'. A timestamp which denotes when the device was installed (if it requires installation).", validate=[OneOf(choices=['Inlet', 'Outlet', 'Entry', 'Exit'], labels=[])])
    distance = fields.Number(description='Location of this device represented by a distance from a starting point. All units are accepted in [CEFACT](https://www.unece.org/cefact.html) code')
    dstAware = fields.Boolean(description='Indicates a device which is Daylight Savings Time Aware (True). In case it is then the Timestamp is automatically adjusted by the device to reflect DST changes. If not (False) the time adjustments must be taken care of by the user.')
    firmwareVersion = fields.String(description='The firmware version of this device.')
    hardwareVersion = fields.String(description='The hardware version of this device.')
    id = fields.Field(required=True, description='Unique identifier of the entity')
    ipAddress = fields.List(fields.String(), description='List of IP address of the device. It can be a comma separated list of values if the device has more than one IP address.')
    location = fields.Field(description='Geojson reference to the item. It can be Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon')
    macAddress = fields.String(description='The MAC address of the device.', validate=[Regexp(regex=re.compile('^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$'))])
    mcc = fields.String(description='This property identifies the Mobile Country Code')
    mnc = fields.String(description="This property identifies the Mobile Network Code (MNC) of the network the device is attached to. The MNC is used in combination with a Mobile Country Code (MCC) (also known as a 'MCC / MNC tuple') to uniquely identify a mobile phone operator/carrier using the GSM, CDMA, iDEN, TETRA and 3G / 4G public land mobile networks and some satellite mobile networks.")
    name = fields.String(description='The name of this item.')
    osVersion = fields.String(description='The version of the host operating system device.')
    owner = fields.List(fields.Nested(lambda: DeviceOwnerItem(), description='Property. Unique identifier of the entity'), description='A List containing a JSON encoded sequence of characters referencing the unique Ids of the owner(s)')
    provider = fields.String(description='The provider of the device.')
    refDeviceModel = fields.Field(description='Model of the device')
    relativePosition = fields.String(description='Location of this device in a coordinate system according to its local emplacement.')
    rssi = fields.Number(description='Received signal strength indicator for a wireless enabled device. It must be expressed in dBm or mW, use unitcode to set it out. ')
    seeAlso = fields.Field(description='list of uri pointing to additional resources about the item')
    serialNumber = fields.String(description='The serial number assigned by the manufacturer.')
    softwareVersion = fields.String(description='The software version of this device.')
    source = fields.String(description='A sequence of characters giving the original source of the entity data as a URL. Recommended to be the fully qualified domain name of the source provider, or the URL to the source object.')
    supportedProtocol = fields.List(fields.String(validate=[OneOf(choices=['3g', 'bluetooth', 'bluetooth LE', 'cat-m', 'coap', 'ec-gsm-iot', 'gprs', 'http', 'lwm2m', 'lora', 'lte-m', 'mqtt', 'nb-iot', 'onem2m', 'sigfox', 'ul20', 'websocket'], labels=[])]), description='Supported protocol(s) or networks')
    type = fields.String(required=True, description='NGSI Entity type. It has to be Device', validate=[OneOf(choices=['Device'], labels=[])])
    value = fields.String(description="A observed or reported value. For actuator devices, it is an attribute that allows a controlling application to change the actuation setting. For instance, a switch device which is currently _on_ can report a value 'on' of type 'Text'. Obviously, in order to toggle the referred switch, this attribute value will have to be changed to 'off'.")

    class Meta:
        unknown = INCLUDE



class DeviceOwnerItem(Schema):
    """Property. Unique identifier of the entity"""

    class Meta:
        unknown = INCLUDE



class DeviceControlledAssetItem(Schema):

    class Meta:
        unknown = INCLUDE



class DeviceConfigurationItem(Schema):
    parameter = fields.String()
    value = fields.String()

    class Meta:
        unknown = INCLUDE



class DeviceAddress(Schema):
    """The mailing address"""
    addressCountry = fields.String(description="Property. The country. For example, Spain. Model:'https://schema.org/addressCountry'")
    addressLocality = fields.String(description="Property. The locality in which the street address is, and which is in the region. Model:'https://schema.org/addressLocality'")
    addressRegion = fields.String(description="Property. The region in which the locality is, and which is in the country. Model:'https://schema.org/addressRegion'")
    postOfficeBoxNumber = fields.String(description="Property. The post office box number for PO box addresses. For example, 03578. Model:'https://schema.org/postOfficeBoxNumber'")
    postalCode = fields.String(description="Property. The postal code. For example, 24004. Model:'https://schema.org/https://schema.org/postalCode'")
    streetAddress = fields.String(description="Property. The street address. Model:'https://schema.org/streetAddress'")

    class Meta:
        unknown = INCLUDE



class DeviceMeasurement(Schema):
    """Description of a generic measurement entity coming from a device or other data source."""
    address = fields.Nested(lambda: DeviceMeasurementAddress(), description='The mailing address')
    alternateName = fields.String(description='An alternative name for this item')
    areaServed = fields.String(description='The geographic area where a service or offered item is provided')
    controlledProperty = fields.String(description='Property being measured by the device')
    dataProvider = fields.String(description='A sequence of characters identifying the provider of the harmonised data entity.')
    dateCreated = fields.AwareDateTime(description='Entity creation timestamp. This will usually be allocated by the storage platform.')
    dateModified = fields.AwareDateTime(description='Timestamp of the last modification of the entity. This will usually be allocated by the storage platform.')
    dateObserved = fields.AwareDateTime(description='The date and time of this observation in ISO8601 UTC format')
    description = fields.String(description='A description of this item')
    deviceType = fields.String(description='Type of device taking the measurement')
    id = fields.Field(required=True, description='Unique identifier of the entity')
    location = fields.Field(description='Geojson reference to the item. It can be Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon')
    measurementType = fields.String(description='The type of measurement to be taken')
    name = fields.String(description='The name of this item.')
    numValue = fields.Number(description='Numerical value of the measurement')
    outlier = fields.Boolean(description='Value for marking the measurement to be specially processed')
    owner = fields.List(fields.Nested(lambda: DeviceMeasurementOwnerItem(), description='Property. Unique identifier of the entity'), description='A List containing a JSON encoded sequence of characters referencing the unique Ids of the owner(s)')
    refDevice = fields.Field(description='Device taking the measurement')
    seeAlso = fields.Field(description='list of uri pointing to additional resources about the item')
    source = fields.String(description='A sequence of characters giving the original source of the entity data as a URL. Recommended to be the fully qualified domain name of the source provider, or the URL to the source object.')
    textValue = fields.String(description='Textual value of the measurement')
    type = fields.String(required=True, description='NGSI Entity type. It has to be Measurement', validate=[OneOf(choices=['DeviceMeasurement'], labels=[])])
    unit = fields.String(description='Units of the measurement. In case of use of an acronym use units accepted in [CEFACT](https://www.unece.org/cefact.html) code.')

    class Meta:
        unknown = INCLUDE



class DeviceMeasurementOwnerItem(Schema):
    """Property. Unique identifier of the entity"""

    class Meta:
        unknown = INCLUDE



class DeviceMeasurementAddress(Schema):
    """The mailing address"""
    addressCountry = fields.String(description="Property. The country. For example, Spain. Model:'https://schema.org/addressCountry'")
    addressLocality = fields.String(description="Property. The locality in which the street address is, and which is in the region. Model:'https://schema.org/addressLocality'")
    addressRegion = fields.String(description="Property. The region in which the locality is, and which is in the country. Model:'https://schema.org/addressRegion'")
    postOfficeBoxNumber = fields.String(description="Property. The post office box number for PO box addresses. For example, 03578. Model:'https://schema.org/postOfficeBoxNumber'")
    postalCode = fields.String(description="Property. The postal code. For example, 24004. Model:'https://schema.org/https://schema.org/postalCode'")
    streetAddress = fields.String(description="Property. The street address. Model:'https://schema.org/streetAddress'")

    class Meta:
        unknown = INCLUDE



class VirtualMeter(Schema):
    id = fields.String(required=True)
    description = fields.String()
    address = fields.Nested(lambda: Address(), description='The mailing address')
    areaServed = fields.String(description='The geographic area where a service or offered item is provided')
    submeterIds = fields.List(fields.String(), required=True, description='List of IDs of physical or virtual meters that this vm represents.')
    supermeterIds = fields.List(fields.String(), description='List of IDs super meters that this virtual meter is part of.')
    comment = fields.String(description='A comment about the virtual meter.')
    class Meta:
        unknown = INCLUDE



class WaterForecastItem(Schema):
    id = fields.String(required=True)
    datePredicted = fields.AwareDateTime(required=True, description='The date when the data point is predicted to be observed.')
    numValue = fields.Number(required=True)
    unit = fields.String(description='Units of the measurement. In case of use of an acronym use units accepted in [CEFACT](https://www.unece.org/cefact.html) code.')
    refDevice = fields.String(required=True, description='The physical meter (device) or virtual meter that this forecast corresponds to.')
    type = fields.String(description='(NGSI Entity type. It has to be WaterForecast. Note that this is only preliminary, as the type WaterForecast does not exist yet.)')

    class Meta:
        unknown = INCLUDE



class WaterForecastTimeSeries(Schema):
    forecast = fields.List(fields.Nested(lambda: WaterForecastItem()), required=True)
    forecastAnalysis = fields.List(fields.Nested(lambda: ForecastAnalysisItem()), description='TODO. Contains components like daily or weekly seasonalities that sum up to the original forecast and can be used for analysis purposes.')

    class Meta:
        unknown = INCLUDE



class ForecastAnalysisItem(Schema):
    name = fields.String()
    forecast = fields.List(fields.Nested(lambda: WaterForecastItem()))

    class Meta:
        unknown = INCLUDE



class ForecastingConfiguration(Schema):
    """Contains information on default algorithms, model re-training frequency, etc... for a specific meter."""
    refMeter = fields.String(description='The id of the associated virtual or phyiscal meter.')
    defaultAlgorithm = fields.String(description='The algorithm set as default for forecasting.')

    class Meta:
        unknown = INCLUDE



class TrainArguments(Schema):
    """The information needed to train a model"""
    algorithm = fields.String(description='Algorithm to use for training a forecasting model.', validate=[OneOf(choices=['TripleExponentialSmoothing', 'AutoArima', 'Prophet', 'XGBoost', 'Nbeats', 'TemporalFusionTransformer'], labels=[])])
    setDefault = fields.Boolean(description='Whether to set the newly trained model as default for the associated meter when creating forecasts.', missing=lambda: False)
    hyperParamSearch = fields.Boolean(description='Whether to perform hyperparameter optimization to automatically find the best hyperparameters for the training algorithm. Takes significantly more time, as many different combinations of parameters are evaluated.', missing=lambda: False)
    numConfigurations = fields.Integer(description='Number of different hyperparameter configurations to try out. Only used if hyperParamSearch is true.', missing=lambda: RAY_N_MODELS)
    class Meta:
        unknown = INCLUDE



class AlgorithmSpec(Schema):
    name = fields.String(description='Name of the algorithm.')
    description = fields.String(description='Description of the algorithm.')
    parameters = fields.List(fields.Nested(lambda: ParameterSpec()), description='The parameters that have to be specified for this algorithm.')

    class Meta:
        unknown = INCLUDE



class ParameterSpec(Schema):
    name = fields.String(description='Name of the parameter.')
    description = fields.String(description='Description of the parameter.')
    type = fields.String(description='Type of the parameter.', validate=[OneOf(choices=['categorical', 'integer', 'float', 'boolean'], labels=[])])
    default = fields.String(description='Default value of the parameter.')
    options = fields.Nested(lambda: ParameterOptions(), description='The options for the parameter. Either a range of values or a list of values.')

    class Meta:
        unknown = INCLUDE



class ParameterOptions(Schema):
    min = fields.Float(description='Minimum value of the parameter.')
    max = fields.Float(description='Maximum value of the parameter.')
    categories = fields.List(fields.Raw(), description='List of possible values for the parameter.')
    class Meta:
        unknown = INCLUDE



class Address(Schema):
    """The mailing address"""
    addressCountry = fields.String(description="Property. The country. For example, Spain. Model:'https://schema.org/addressCountry'")
    addressLocality = fields.String(description="Property. The locality in which the street address is, and which is in the region. Model:'https://schema.org/addressLocality'")
    addressRegion = fields.String(description="Property. The region in which the locality is, and which is in the country. Model:'https://schema.org/addressRegion'")
    postOfficeBoxNumber = fields.String(description="Property. The post office box number for PO box addresses. For example, 03578. Model:'https://schema.org/postOfficeBoxNumber'")
    postalCode = fields.String(description="Property. The postal code. For example, 24004. Model:'https://schema.org/https://schema.org/postalCode'")
    streetAddress = fields.String(description="Property. The street address. Model:'https://schema.org/streetAddress'")

    class Meta:
        unknown = INCLUDE



class Evaluation(Schema):
    """Evaluation after model training."""
    modelId = fields.String(description='Id of the associated model.')
    refMeter = fields.String(description='Id of the associated meter.')
    mae = fields.Number(description='Mean absolute error obtained on the test data.')
    mse = fields.Number(description='mean squared error obtained on the test data.')
    mape = fields.Number(description='mean absolute percentage error obtained on the test data.')
    r2 = fields.Number(description='coefficient of determination (R squared) obtained on the test data.')
    trainTestSplit = fields.Number(description='Portion of full dataset used for training (and thus implicitly portion of dataset used for evaluation).')
    datesTestSet = fields.List(fields.String(description='Date in ISO8601 UTC format.'), description='Array of dates used in the test set.')
    yPredTestSet = fields.List(fields.Number(), description='Array of predicted values in the test set.')
    yTrueTestSet = fields.List(fields.Number(), description='Array of true / actual values in the test set.')

    class Meta:
        unknown = INCLUDE



class ProphetHyperparameters(Schema):

    class Meta:
        unknown = INCLUDE



class TripleExponentialSmoothingHyperparameters(Schema):

    class Meta:
        unknown = INCLUDE



class AutoArimaHyperparameters(Schema):

    class Meta:
        unknown = INCLUDE



class XGBoostHyperparameters(Schema):
    colsample_bytree = fields.Number(description='Subsample ratio of columns when constructing each tree.')
    gamma = fields.Number(description='Minimum loss reduction required to make a further partition on a leaf node of the tree.')
    max_depth = fields.Integer(description='Maximum depth of a tree.')
    min_child_weight = fields.Number(description='Minimum sum of instance weight (hessian) needed in a child.')
    learning_rate = fields.Number(description="Boosting learning rate (xgb's 'eta').")

    class Meta:
        unknown = INCLUDE



class NbeatsHyperparameters(Schema):
    input_chunk_length = fields.Integer(description='Number of past hours to use for prediction. Given a value of 72, the model will use the past 72 hours to predict the next 24 hours.')
    num_blocks = fields.Integer(description='The number of blocks per stack.')
    num_layers = fields.Integer(description='Number of fully connected layers with ReLu activation per block.')
    layer_widths = fields.Integer(description='Number of neurons of the fully connected layers with ReLu activation in the blocks.')
    batch_size = fields.Integer(description='Number of samples to process per update step.')
    n_epochs = fields.Integer(description='Number of training epochs.')

    class Meta:
        unknown = INCLUDE



class TemporalFusionTransformerHyperparameters(Schema):
    learning_rate = fields.Number(description='Learning rate for the optimizer.')
    hidden_size = fields.Integer(description='Number of hidden units in the encoder and decoder layers.')
    attention_head_size = fields.Integer(description='Size of the attention heads in the multi-head attention mechanism.')
    dropout = fields.Number(description='Dropout rate used in the model.')
    hidden_continuous_size = fields.Integer(description='Size of the hidden layers in the continuous variable network.')

    class Meta:
        unknown = INCLUDE
